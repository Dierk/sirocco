module sirocco.Sirocco where

import sirocco.Util
import sirocco.JDBC
import sirocco.FDBC

--- Creates a new connection
createConnection :: String -> String -> String -> IO Connection
createConnection uri username password = DriverManager.getConnection uri username password

{--
  This type class represents possible parameters for a PreparedStatement instance
-}
class PreparedParam a where
    setParam :: PreparedStatement -> (Int, Maybe a) -> IO PreparedStatement

instance PreparedParam Int where
    setParam stmt (pos, value) = useWith PreparedStatement.setInt stmt pos value

instance PreparedParam String where
    setParam stmt (pos, value) = useWith PreparedStatement.setString stmt pos value

instance PreparedParam Bool where
  setParam stmt (pos, value) = useWith PreparedStatement.setBoolean stmt pos value

instance PreparedParam Byte where
  setParam stmt (pos, value) = useWith PreparedStatement.setByte stmt pos value

instance PreparedParam Double where
  setParam stmt (pos, value) = useWith PreparedStatement.setDouble stmt pos value

instance PreparedParam Float where
  setParam stmt (pos, value) = useWith PreparedStatement.setFloat stmt pos value

instance PreparedParam Long where
  setParam stmt (pos, value) = useWith PreparedStatement.setLong stmt pos value

instance PreparedParam Short where
  setParam stmt (pos, value) = useWith PreparedStatement.setShort stmt pos value

--- Utility function to reduce the boilerplate code to create a PreparedParam instance
useWith :: (PreparedStatement -> Int -> a -> IO()) -> PreparedStatement -> Int -> Maybe a -> IO PreparedStatement
useWith fn stmt pos value = case value of
  Just v  -> do
    _ <- fn stmt pos v
    return stmt
  Nothing -> return stmt

{--
    Sets parameters in a PreparedStatement query. Parameters are taken from a list of
    tuples of type (Int, Maybe a). The first integer is the position in the query and
    the second part represents the possible value
-}
setParams :: (PreparedParam a) => PreparedStatement -> [(Int, Maybe a)] -> IO PreparedStatement
setParams stmt []     = return stmt
setParams stmt (x:xs) = do
  _ <- setParam stmt x
  setParams stmt xs

{--
    Instance to show SqlValue instances as a String
-}
instance Show SqlValue where
    show (SqlString s)    = "String: "   ++ s
    show (SqlInt s)       = "Int: "      ++ show s
    show (SqlLong s)      = "Long: "     ++ show s
    show (SqlBool s)      = "Bool: "     ++ show s
    show (SqlInteger s)   = "Integer:"   ++ show s
    show (SqlFloat s)     = "Float:"     ++ show s
    show (SqlDouble s)    = "Double:"    ++ show s
    show (SqlDecimal s)   = "Decimal:"   ++ (BigDecimal.toString s)
    show (SqlChar s)      = "Char:"      ++ show s
    show (SqlDate s)      = "Date:"      ++ (Date.toString s)
    show (SqlTime s)      = "Time:"      ++ (Time.toString s)
    show (SqlTimestamp s) = "Timestamp:" ++ (Timestamp.toString s)
    show (SqlNull)        = "Null:"
    show t                = "Some value"

{--
    Executes a given query to modify the state of the database: create a table,
    drop table... If the query succeed the function will return true, otherwise
    it will return false
-}
execute :: IO Connection -> Maybe String -> IO Bool
execute connection sql = do
  conn   <- connection
  case sql of
    Just q -> do
        stmt   <- Connection.prepareStatement conn q
        PreparedStatement.execute stmt
    Nothing -> pure false

{--
    Executes queries of type UPDATE/INSERT. It will be returning those
    affected rows
-}
update :: IO Connection -> Maybe String -> IO Int
update connection msql = do
  conn   <- connection
  case msql of
    Just sql -> do
      stmt   <- Connection.prepareStatement conn sql
      PreparedStatement.executeUpdate stmt
    Nothing  -> pure 0


{--
    Executes a query and returns a list of results
-}
query :: (PreparedParam a) => IO Connection -> Maybe String -> [(Int, Maybe a)] -> IO [CatchAll [SqlValue]]
query connection msql parameters = do
  conn   <- connection
  case msql of
    Just sql -> do
      stmt   <- Connection.prepareStatement conn sql
      stmt'  <- setParams stmt parameters
      rows   <- PreparedStatement.executeQuery stmt'
      takeWhileRight $ repeat $ fetchRow rows
    Nothing -> pure []

{--
    This function maps a list of query results to a specific type of list
-}
mapRowsTo :: ([SqlValue] -> a) -> IO [CatchAll [SqlValue]] ->  IO [a]
mapRowsTo mapper xs = fmap fromRight $ fmap (fmap (fmap mapper)) $ fmap sequence xs

{--
   When invoking the function `fetchRow` it only ask for one row of the
   current ResultSet. Every call to fetchRow returns an IO Right _
   while there are records, once the records have been consumed the
   fetchRow call will return IO Left _ records.
-}
takeWhileRight :: [IO (CatchAll a)] -> IO [(CatchAll a)]
takeWhileRight (x:xs) = do
  y <- x
  case y of
      Right _ -> (y:) <$> (takeWhileRight xs)
      Left  _ -> pure []
takeWhileRight []     = return []
