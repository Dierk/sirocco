{--
 This module handles common database operations such as:

 * Create a connection
 * Create a new statement

-}
module songs.db.Db where

import sirocco.internal.JDBC
import sirocco.internal.FDBC
import songs.data.Util

databaseURI = "jdbc:h2:~/test"

--- Creates a new connection
connection :: IO Connection
connection = DriverManager.getConnection databaseURI "sa" ""

execute :: IO Connection -> Maybe String -> IO Bool
execute connection sql = do
  conn   <- connection
  case sql of
    Just q -> do
        stmt   <- Connection.prepareStatement conn q
        PreparedStatement.execute stmt
    Nothing -> pure false

update :: IO Connection -> Maybe String -> IO Int
update connection msql = do
  conn   <- connection
  case msql of
    Just sql -> do
      stmt   <- Connection.prepareStatement conn sql
      PreparedStatement.executeUpdate stmt
    Nothing  -> pure 0

query :: IO Connection -> Maybe String -> [(Int, String)] -> IO [CatchAll [SqlValue]]
query connection msql parameters = do
  conn   <- connection
  case msql of
    Just sql -> do
      stmt   <- Connection.prepareStatement conn sql
      stmt'  <- setParams stmt parameters
      rows   <- PreparedStatement.executeQuery stmt'
      takeWhileRight $ repeat $ fetchRow rows
    Nothing -> pure []

setParams :: PreparedStatement -> [(Int,String)] -> IO PreparedStatement
setParams stmt []     = return stmt
setParams stmt ((y,z):xs) = do
  _ <- PreparedStatement.setString stmt y z
  setParams stmt xs

instance Show SqlValue where
    show (SqlString s) = "String: " ++ s
    show (SqlInt s)    = "Int: " ++ show s
    show (SqlLong s)   = "Long: " ++ show s
    show t = "Some value"

mapRowsTo :: ([SqlValue] -> a) -> IO [CatchAll [SqlValue]] ->  IO [a]
mapRowsTo mapper xs = fmap fromRight $ fmap (fmap (fmap mapper)) $ fmap sequence xs

{--
   When invoking the function `fetchRow` it only ask for one row of the
   current ResultSet. Every call to fetchRow returns an IO Right _
   while there are records, once the records have been consumed the
   fetchRow call will return IO Left _ records.
-}
takeWhileRight :: [IO (CatchAll a)] -> IO [(CatchAll a)]
takeWhileRight (x:xs) = do
  y <- x
  case y of
      Right _ -> (y:) <$> (takeWhileRight xs)
      Left  _ -> pure []
takeWhileRight []     = return []
